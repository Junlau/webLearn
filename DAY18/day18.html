<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深拷贝，浅拷贝</title>
</head>
<body>
    <!-- <div>
        <div>
            <span>
                <a href="" title=""></a>
            </span>
        </div>
         <span></span>
    </div>
    <div>
        <div>
            <div>
                <span></span>
            </div>
        </div>
    </div> -->
    <span class="msg">Hello World !</span>
    <ul>
        <li>电影</li>
        <li>综艺
            <ul>
                <li>跑男</li>
                <li>爸爸</li>
                <li>真男</li>
            </ul>
        </li>
        <li>剧集</li>
    </ul>
</body>
<script>
    function Person () {

    };


    var obj = {
        name:"liu",
        age:30,
        sex:"male",
        phone:["iphone",["mi"]],
        wife:{
            name:"zhu",
            age:27
        }
    };

    // [] instanceof Object = true
    
    var obj1 = {};

    function copyObject(target, origin) {
        var target = target || {};
        toStr = Object.prototype.toString;
        arrStr = "[object Array]";

        for (let prop in origin) {
            //判断是自己的属性而不是原型链上的属性
            if(origin.hasOwnProperty(prop)){
                //使用 typeof 来判断是不是值对象
                if(typeof(origin[prop]) == "object") {
                    //使用 toSting 来判断是数组还是对象，并且不等于 null
                    if(toStr.call(origin[prop]) == arrStr && origin[prop] !== "null") {
                        target[prop] = [];
                    } else {
                        target[prop] = {};
                    }
                    //递归
                    //数组也可以用 for in
                    copyObject(target[prop], origin[prop]);
                } else {
                    target[prop] = origin[prop];
                }
            }
        }
        return target;
    }


    //下面的方法有个问题，如果数组里面还有数组，达不到深拷贝的目的
    // function copyObject(target, origin) {
    //     for (let prop in origin) {
    //         if(origin[prop] instanceof Array) {
    //             let tempArray = [];
    //             for(let i = 0; i < origin[prop].length; i++){
    //                 tempArray.push(origin[prop][i]);
    //             }
    //             target[prop] = tempArray;
    //         } else if(origin[prop] instanceof Object) {
    //             let tempObject = {};
    //             target[prop] = copyObject(tempObject, origin[prop]);
    //         } else {
    //             target[prop] = origin[prop];
    //         }
    //     }
    //     return target;
    // }

    copyObject(obj1, obj);
    obj1.phone.push("mi");
    console.log(obj1);
    

    function type (target) {
        if (typeof(target) == "object") {
            let typeStr = Object.prototype.toString.call(target);
            let strArray = typeStr.split(" ");
            let str = strArray[1];
            str = str.substring(0,str.length - 1);
            return str;
        } else {
            console.log(typeof(target));
            return typeof(target);
        }
    }

    function type2 (target) {
        let allObject = {
            "[object Array]" : "array",
            "[object Object]" : "Object",
            "[object Number]" : "Number--object",
            "[object Boolean]" : "Boolean--object",
            "[object String]" : "String--object"
        };
        
        if (target === null) {
            return "null";
        } else if (typeof(target) == "object") {
            let typeStr = Object.prototype.toString.call(target);
            return allObject[typeStr];
        } else {
            return typeof(target);
        }
    }


    //数组去重方法
    // Array.prototype.unique = function () {
    //     let tempObject = {};
    //     for (let i = 0; i < this.length; i++) {
    //         tempObject[String(this[i])] = this[i];
    //     }
    //     return Object.values(tempObject);
    // }
    
    //数组去重方法，数组里面存对象去重会有问题
    Array.prototype.unique = function () {
        let tempObject = {};
        let arr = [];
        for (let i = 0; i < this.length; i++) {
            if(!tempObject[this[i]]) {
                tempObject[this[i]]="abc";
                arr.push(this[i]);
            }
        }
        return arr;
    }


    //一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母
    function firstDisplaySingle (target) {
        let tempObject = {};
        for(let i = 0; i < target.length; i++) {
            if (!tempObject[target[i]]) {
                tempObject[target[i]] = 1;
            } else {
                tempObject[target[i]] = tempObject[target[i]] + 1;
            }
        }

        for (let key in tempObject) {
            if (tempObject.hasOwnProperty(key)) {
                if (tempObject[key] == 1) {
                    return key;
                }
            }
        }
        return null;
    }

    //字符串去重
    String.prototype.unique = function () {
        let tempObject = {};
        let arr = [];
        for(let i = 0; i < this.length; i++) {
            if (!tempObject[this[i]]) {
                tempObject[this[i]] = "abc";
                arr.push(this[i]);
            }
        }
        return arr.join("");
    }


    //自定义标签并插入
    // var div = document.createElement('div');
    // div.setAttribute('class', 'example');

    // var p = document.createElement('p');
    // p.innerHTML = "LJ";
    // p.setAttribute('class','slogan');
    // div.appendChild(p);

    // document.body.appendChild(div);
    
    //遍历元素节点树（在原型链上编程）
    Element.prototype.eachAll = function () {
        var list = [];
        list.push(this);
        while(list.length) {
            let child = list[0];
            console.log(child.nodeName + '\n');
            if (child.hasChildNodes) {
                for(let i = 0; i < child.children.length; i++) {
                    let otherChild = child.children[i];
                    list.push(otherChild);
                }
            }
            list.shift();
        }
    };

    Element.prototype.eachAll2 = function () {
        console.log(this.nodeName);
        if (this.hasChildNodes) {
            for(let i = 0; i < this.children.length; i++) {
                let otherChild = this.children[i];
                otherChild.eachAll();
            }
        }
    };





</script>
</html>