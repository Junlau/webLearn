<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深拷贝，浅拷贝</title>
</head>
<body>
    
</body>
<script>
    var obj = {
        name:"liu",
        age:30,
        sex:"male",
        phone:["iphone",["mi"]],
        wife:{
            name:"zhu",
            age:27
        }
    };

    // [] instanceof Object = true
    
    var obj1 = {};

    function copyObject(target, origin) {
        var target = target || {};
        toStr = Object.prototype.toString;
        arrStr = "[object Array]";

        for (let prop in origin) {
            //判断是自己的属性而不是原型链上的属性
            if(origin.hasOwnProperty(prop)){
                //使用 typeof 来判断是不是值对象
                if(typeof(origin[prop]) == "object") {
                    //使用 toSting 来判断是数组还是对象，并且不等于 null
                    if(toStr.call(origin[prop]) == arrStr && origin[prop] !== "null") {
                        target[prop] = [];
                    } else {
                        target[prop] = {};
                    }
                    //递归
                    //数组也可以用 for in
                    copyObject(target[prop], origin[prop]);
                } else {
                    target[prop] = origin[prop];
                }
            }
        }
        return target;
    }


    //下面的方法有个问题，如果数组里面还有数组，达不到深拷贝的目的
    // function copyObject(target, origin) {
    //     for (let prop in origin) {
    //         if(origin[prop] instanceof Array) {
    //             let tempArray = [];
    //             for(let i = 0; i < origin[prop].length; i++){
    //                 tempArray.push(origin[prop][i]);
    //             }
    //             target[prop] = tempArray;
    //         } else if(origin[prop] instanceof Object) {
    //             let tempObject = {};
    //             target[prop] = copyObject(tempObject, origin[prop]);
    //         } else {
    //             target[prop] = origin[prop];
    //         }
    //     }
    //     return target;
    // }

    copyObject(obj1, obj);
    obj1.phone.push("mi");
    console.log(obj1);
    

    function type (target) {
        if (typeof(target) == "object") {
            let typeStr = Object.prototype.toString.call(target);
            let strArray = typeStr.split(" ");
            let str = strArray[1];
            str = str.substring(0,str.length - 1);
            return str;
        } else {
            console.log(typeof(target));
            return typeof(target);
        }
    }

    function type2 (target) {
        let allObject = {
            "[object Array]" : "array",
            "[object Object]" : "Object",
            "[object Number]" : "Number--object",
            "[object Boolean]" : "Boolean--object",
            "[object String]" : "String--object"
        };
        
        if (target === null) {
            return "null";
        } else if (typeof(target) == "object") {
            let typeStr = Object.prototype.toString.call(target);
            return allObject[typeStr];
        } else {
            return typeof(target);
        }
    }


    //数组去重方法
    // Array.prototype.unique = function () {
    //     let tempObject = {};
    //     for (let i = 0; i < this.length; i++) {
    //         tempObject[String(this[i])] = this[i];
    //     }
    //     return Object.values(tempObject);
    // }
    
    //数组去重方法，数组里面存对象去重会有问题
    Array.prototype.unique = function () {
        let tempObject = {};
        let arr = [];
        for (let i = 0; i < this.length; i++) {
            if(!tempObject[this[i]]) {
                tempObject[this[i]]="abc";
                arr.push(this[i]);
            }
        }
        return arr;
    }

</script>
</html>